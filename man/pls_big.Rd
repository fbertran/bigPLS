% Generated by hand for pls_big and matrixpls_stream_bigmatrix
\name{pls_big}
\alias{pls_big}
\alias{matrixpls_stream_bigmatrix}
\title{Partial least squares for bigmemory matrices}
\description{
\code{pls_big()} fits a partial least squares (PLS) model using a column-major
NIPALS algorithm implemented in C++ that operates directly on
\link[bigmemory]{big.matrix} inputs. Both in-memory and file-backed matrices are
supported. \code{matrixpls_stream_bigmatrix()} provides a pure R fallback that
performs the same computation by streaming over row chunks of a file-backed
matrix without loading it fully into memory.
}
\usage{
pls_big(
  X,
  Y,
  ncomp = 2L,
  tol = 1e-6,
  max_iter = 500L,
  stream = FALSE,
  num.rows.chunk = 1e6,
  backingfile = NULL,
  backingpath = NULL,
  descriptorfile = NULL,
  type = "double",
  ...
)

matrixpls_stream_bigmatrix(
  X,
  Y,
  ncomp = 2L,
  tol = 1e-6,
  max_iter = 500L,
  num.rows.chunk = 1e6,
  ...
)
}
\arguments{
  \item{X}{Either a \code{bigmemory::big.matrix}, a
    \code{bigmemory::big.matrix.descriptor}, or a character path to a delimited
    file that can be read with \code{bigmemory::read.big.matrix()}.}
  \item{Y}{Numeric response matrix with matching number of rows. Vectors are
    coerced to a one-column matrix.}
  \item{ncomp}{Number of latent components to extract.}
  \item{tol}{Convergence tolerance for the iterative updates.}
  \item{max_iter}{Maximum number of iterations for the NIPALS inner loop.}
  \item{stream}{Logical; when \code{TRUE}, force the chunk-wise R
    implementation via \code{matrixpls_stream_bigmatrix()}.}
  \item{num.rows.chunk}{Number of rows to load per chunk when streaming.}
  \item{backingfile, backingpath, descriptorfile}{Optional arguments passed to
    \code{bigmemory::read.big.matrix()} when \code{X} is a file path.}
  \item{type}{Storage mode to use when reading from a file path.}
  \item{\dots}{Reserved for future extensions.}
}
\value{
A list with components \code{scores}, \code{Yscores}, \code{weights},
\code{loadings}, \code{Yloadings}, and \code{coefficients} that can be used for
subsequent modelling.
}
\details{
The compiled routine uses matrix operations optimised for the column-major
layout of \pkg{bigmemory}. The streaming implementation reuses the chunking
logic from \code{bigscale()} to iteratively accumulate the same quantities
without materialising the full design matrix in memory.
}
\seealso{
\code{bigmemory::big.matrix()}, \code{bigscale()}
}
\examples{
if (requireNamespace("bigmemory", quietly = TRUE)) {
  set.seed(123)
  X <- matrix(rnorm(40), nrow = 10)
  Y <- matrix(rnorm(20), nrow = 10, ncol = 2)
  bm <- bigmemory::as.big.matrix(X)
  fit <- pls_big(bm, Y, ncomp = 2)
  str(fit)
}
}
